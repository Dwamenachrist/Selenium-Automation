<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Download {SERIES_NAME} Media</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&display=swap">
  <style>
    :root {
      --primary: #e50914;
      --primary-hover: #f40612;
      --secondary: #032541;
      --text: #333;
      --text-light: #eee;
      --bg-light: #f8f9fa;
      --bg-dark: #141414;
      --card-light: #ffffff;
      --card-dark: #1f1f1f;
      --border-light: #e6e6e6;
      --border-dark: #333;
      --success: #01b4e4;
      --downloaded: rgba(1, 180, 228, 0.15);
      --shadow-light: 0 8px 30px rgba(0, 0, 0, 0.12);
      --shadow-dark: 0 8px 30px rgba(0, 0, 0, 0.3);
      --transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
      --subtitle-color: #01b4e4;
      --video-color: #e67e22;
      --other-color: #9b59b6;
      --hd-color: #27ae60;
      --sd-color: #f39c12;
      --lq-color: #95a5a6;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Montserrat', sans-serif;
      background-color: var(--bg-light);
      color: var(--text);
      margin: 0;
      padding: 0;
      min-height: 100vh;
      transition: var(--transition);
    }

    .app-container {
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }

    header {
      background-color: var(--secondary);
      color: white;
      padding: 1rem;
      text-align: center;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }

    .logo {
      font-size: 1.8rem;
      font-weight: 700;
      margin: 0;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .logo span {
      color: var(--primary);
    }

    .logo-icon {
      margin-right: 10px;
      font-size: 2rem;
    }

    main {
      flex: 1;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 2rem 1rem;
    }

    .container {
      width: 100%;
      max-width: 800px;
      background: var(--card-light);
      padding: 2rem;
      border-radius: 16px;
      box-shadow: var(--shadow-light);
      transition: var(--transition);
    }

    h1 {
      margin-bottom: 1.5rem;
      font-weight: 600;
      font-size: 1.8rem;
      text-align: center;
    }

    h2 {
      font-size: 1.4rem;
      margin-bottom: 1rem;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .search-container {
      display: flex;
      gap: 10px;
      margin-bottom: 1.5rem;
    }

    input[type=text] {
      flex: 1;
      padding: 12px 16px;
      border: 2px solid var(--border-light);
      border-radius: 8px;
      font-size: 1rem;
      transition: var(--transition);
      font-family: inherit;
    }

    input[type=text]:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(229, 9, 20, 0.2);
    }

    button {
      padding: 12px 20px;
      border: none;
      background-color: var(--primary);
      color: white;
      font-size: 1rem;
      font-weight: 600;
      border-radius: 8px;
      cursor: pointer;
      transition: var(--transition);
      font-family: inherit;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    button:hover {
      background-color: var(--primary-hover);
      transform: translateY(-2px);
    }

    button:active {
      transform: translateY(0);
    }

    .season-container {
      margin-bottom: 2rem;
    }

    .season-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background-color: var(--secondary);
      color: white;
      padding: 12px 16px;
      border-radius: 8px 8px 0 0;
      cursor: pointer;
    }

    .season-header:hover {
      background-color: #043b63;
    }

    .season-content {
      border: 2px solid var(--border-light);
      border-top: none;
      border-radius: 0 0 8px 8px;
      overflow: hidden;
      transition: var(--transition);
      max-height: 0;
      overflow: hidden;
    }

    .season-content.open {
      max-height: 500px;
      overflow-y: auto;
    }

    .episode-list-container {
      margin: 1.5rem 0;
      border-radius: 12px;
      border: 2px solid var(--border-light);
      overflow: hidden;
      transition: var(--transition);
    }

    .episode-list-header {
      background-color: var(--secondary);
      color: white;
      padding: 12px 16px;
      font-weight: 600;
      display: flex;
      justify-content: space-between;
    }

    .selection-controls {
      display: flex;
      gap: 10px;
      margin-top: 10px;
      flex-wrap: wrap;
    }

    .selection-controls button {
      padding: 8px 12px;
      font-size: 0.85rem;
      background-color: var(--secondary);
    }

    ul {
      list-style: none;
      padding: 0;
      margin: 0;
      max-height: 350px;
      overflow-y: auto;
      scrollbar-width: thin;
      scrollbar-color: var(--primary) var(--bg-light);
    }

    ul::-webkit-scrollbar {
      width: 8px;
    }

    ul::-webkit-scrollbar-track {
      background: var(--bg-light);
    }

    ul::-webkit-scrollbar-thumb {
      background-color: var(--primary);
      border-radius: 20px;
    }

    li {
      padding: 16px;
      border-bottom: 1px solid var(--border-light);
      cursor: pointer;
      transition: var(--transition);
      display: flex;
      align-items: center;
    }

    li:last-child {
      border-bottom: none;
    }

    li:hover {
      background-color: rgba(229, 9, 20, 0.05);
    }

    li.downloaded {
      background-color: var(--downloaded);
    }

    li input[type="checkbox"] {
      margin-right: 12px;
      width: 18px;
      height: 18px;
      accent-color: var(--primary);
    }

    .media-type {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 0.8rem;
      font-weight: 600;
      margin-left: 8px;
      color: white;
    }

    .media-type.subtitle {
      background-color: var(--subtitle-color);
    }

    .media-type.video {
      background-color: var(--video-color);
    }

    .media-type.other {
      background-color: var(--other-color);
    }

    .resolution-badge {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 0.8rem;
      font-weight: 600;
      margin-left: 8px;
      color: white;
    }

    .resolution-badge.hd {
      background-color: var(--hd-color);
    }

    .resolution-badge.sd {
      background-color: var(--sd-color);
    }

    .resolution-badge.lq {
      background-color: var(--lq-color);
    }

    .resolution-selector {
      display: flex;
      gap: 5px;
      margin-left: auto;
    }

    .resolution-btn {
      padding: 2px 8px;
      font-size: 0.8rem;
      border-radius: 4px;
      background-color: var(--secondary);
      opacity: 0.7;
      cursor: pointer;
    }

    .resolution-btn:hover {
      opacity: 1;
      transform: translateY(-1px);
    }

    .resolution-btn.hd {
      background-color: var(--hd-color);
    }

    .resolution-btn.sd {
      background-color: var(--sd-color);
    }

    .resolution-btn.lq {
      background-color: var(--lq-color);
    }

    .resolution-btn.active {
      opacity: 1;
      transform: translateY(-1px);
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
    }

    .actions {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 1.5rem;
      gap: 10px;
      flex-wrap: wrap;
    }

    .download-btn {
      background: var(--primary);
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 12px 24px;
    }

    .toggle-btn {
      background: var(--secondary);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .toggle-btn:hover {
      background: #043b63;
    }

    .progress {
      margin-top: 1rem;
      font-size: 0.9rem;
      color: var(--text);
      text-align: center;
      height: 24px;
      transition: var(--transition);
    }

    .progress-bar {
      height: 6px;
      width: 100%;
      background-color: var(--border-light);
      border-radius: 3px;
      margin-top: 8px;
      overflow: hidden;
      display: none;
    }

    .progress-bar-fill {
      height: 100%;
      background-color: var(--primary);
      width: 0%;
      transition: width 0.3s ease;
    }

    .toast {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: var(--success);
      color: white;
      padding: 12px 20px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      transform: translateY(100px);
      opacity: 0;
      transition: all 0.3s ease;
      z-index: 1000;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .toast.show {
      transform: translateY(0);
      opacity: 1;
    }

    .selected-count {
      background: var(--secondary);
      color: white;
      padding: 4px 8px;
      border-radius: 12px;
      font-size: 0.8rem;
      margin-left: 8px;
    }

    .range-container {
      display: flex;
      gap: 10px;
      margin-bottom: 1rem;
    }

    .download-settings {
      margin-top: 1rem;
      padding: 1rem;
      border: 1px solid var(--border-light);
      border-radius: 8px;
      transition: var(--transition);
    }

    .download-settings h3 {
      margin-bottom: 0.5rem;
      font-size: 1rem;
    }

    .setting-row {
      display: flex;
      align-items: center;
      margin-bottom: 0.5rem;
    }

    .setting-row label {
      flex: 1;
    }

    .setting-row input[type="range"] {
      width: 150px;
    }

    .setting-value {
      width: 50px;
      text-align: right;
      margin-left: 10px;
    }

    .season-badge {
      background-color: var(--primary);
      color: white;
      padding: 2px 8px;
      border-radius: 12px;
      font-size: 0.8rem;
      margin-left: 8px;
    }

    .chevron {
      transition: transform 0.3s ease;
    }

    .chevron.open {
      transform: rotate(180deg);
    }

    .tabs {
      display: flex;
      margin-bottom: 1.5rem;
      border-bottom: 2px solid var(--border-light);
    }

    .tab {
      padding: 10px 20px;
      cursor: pointer;
      border-bottom: 3px solid transparent;
      transition: var(--transition);
      font-weight: 600;
    }

    .tab.active {
      border-bottom-color: var(--primary);
      color: var(--primary);
    }

    .filter-controls {
      display: flex;
      gap: 10px;
      margin-bottom: 1rem;
      flex-wrap: wrap;
    }

    .filter-btn {
      padding: 8px 12px;
      font-size: 0.85rem;
      background-color: var(--secondary);
      opacity: 0.7;
    }

    .filter-btn.active {
      opacity: 1;
      transform: translateY(-2px);
    }

    .filter-btn.subtitle {
      background-color: var(--subtitle-color);
    }

    .filter-btn.video {
      background-color: var(--video-color);
    }

    .filter-btn.other {
      background-color: var(--other-color);
    }

    .resolution-settings {
      margin-top: 1rem;
      padding: 1rem;
      border: 1px solid var(--border-light);
      border-radius: 8px;
      transition: var(--transition);
    }

    .resolution-settings h3 {
      margin-bottom: 0.5rem;
      font-size: 1rem;
    }

    .resolution-options {
      display: flex;
      gap: 10px;
      margin-top: 0.5rem;
    }

    .resolution-option {
      padding: 8px 12px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.9rem;
      font-weight: 600;
      transition: var(--transition);
      border: 2px solid transparent;
    }

    .resolution-option.active {
      border-color: var(--primary);
    }

    .resolution-option.hd {
      background-color: rgba(39, 174, 96, 0.1);
      color: var(--hd-color);
    }

    .resolution-option.sd {
      background-color: rgba(243, 156, 18, 0.1);
      color: var(--sd-color);
    }

    .resolution-option.lq {
      background-color: rgba(149, 165, 166, 0.1);
      color: var(--lq-color);
    }

    .preview-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }

    .preview-container.active {
      opacity: 1;
      pointer-events: all;
    }

    .preview-content {
      max-width: 90%;
      max-height: 90%;
      background-color: var(--card-light);
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    }

    .preview-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 16px;
      background-color: var(--secondary);
      color: white;
    }

    .preview-close {
      background: none;
      border: none;
      color: white;
      font-size: 1.5rem;
      cursor: pointer;
      padding: 0;
      width: 30px;
      height: 30px;
    }

    .preview-body {
      padding: 16px;
      max-height: 70vh;
      overflow-y: auto;
    }

    .preview-video {
      width: 100%;
      max-height: 70vh;
    }

    .preview-subtitle {
      font-family: monospace;
      white-space: pre-wrap;
      padding: 16px;
      background-color: var(--bg-light);
      border-radius: 4px;
      max-height: 60vh;
      overflow-y: auto;
    }

    /* Dark mode styles */
    body.dark {
      background-color: var(--bg-dark);
      color: var(--text-light);
    }

    body.dark .container {
      background-color: var(--card-dark);
      box-shadow: var(--shadow-dark);
    }

    body.dark input[type=text] {
      background-color: #2b2b2b;
      border-color: var(--border-dark);
      color: var(--text-light);
    }

    body.dark .episode-list-container {
      border-color: var(--border-dark);
    }

    body.dark .season-content {
      border-color: var(--border-dark);
    }

    body.dark li {
      border-color: var(--border-dark);
    }

    body.dark li:hover {
      background-color: rgba(229, 9, 20, 0.15);
    }

    body.dark .progress-bar {
      background-color: #333;
    }

    body.dark .download-settings, 
    body.dark .resolution-settings {
      border-color: var(--border-dark);
    }

    body.dark .tabs {
      border-color: var(--border-dark);
    }

    body.dark .preview-content {
      background-color: var(--card-dark);
    }

    body.dark .preview-subtitle {
      background-color: #2b2b2b;
      color: var(--text-light);
    }

    /* Animation keyframes */
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    /* Responsive styles */
    @media (max-width: 768px) {
      .container {
        padding: 1.5rem;
      }

      .search-container, .range-container {
        flex-direction: column;
      }

      button {
        width: 100%;
      }

      .actions {
        flex-direction: column;
        gap: 1rem;
      }

      .toggle-btn, .download-btn {
        width: 100%;
      }

      .selection-controls, .filter-controls {
        flex-direction: column;
      }

      .resolution-options {
        flex-direction: column;
      }
    }
  </style>
</head>
<body>
  <div class="app-container">
    <header>
      <h1 class="logo">
        <span class="logo-icon">🎬</span>
        <span>{SERIES_NAME}</span><span>Media</span>
      </h1>
    </header>

    <main>
      <div class="container">
        <h1>Download {SERIES_NAME} Media</h1>
        
        <div class="tabs">
          <div class="tab active" data-tab="all">All Episodes</div>
          <div class="tab" data-tab="seasons">By Season</div>
        </div>
        
        <div class="search-container">
          <input type="text" id="searchInput" placeholder="Search episodes...">
        </div>
        
        <div class="range-container">
          <input type="text" id="rangeInput" placeholder="Enter range (e.g., S01E02-S01E05 or S02E07)">
          <button onclick="selectRange()">Select Range</button>
        </div>
        
        <div class="filter-controls">
          <button id="filterAll" class="filter-btn active" onclick="filterMedia('all')">All Media</button>
          <button id="filterSubtitle" class="filter-btn subtitle" onclick="filterMedia('subtitle')">Subtitles</button>
          <button id="filterVideo" class="filter-btn video" onclick="filterMedia('video')">Videos</button>
          <button id="filterOther" class="filter-btn other" onclick="filterMedia('other')">Other</button>
        </div>
        
        <div class="resolution-settings">
          <h3>Preferred Video Resolution</h3>
          <p>Select your preferred resolution for video downloads:</p>
          <div class="resolution-options">
            <div id="resHD" class="resolution-option hd active" onclick="setPreferredResolution('hd')">HD (720p+)</div>
            <div id="resSD" class="resolution-option sd" onclick="setPreferredResolution('sd')">SD (480p)</div>
            <div id="resLQ" class="resolution-option lq" onclick="setPreferredResolution('lq')">Low Quality</div>
          </div>
        </div>
        
        <div class="selection-controls">
          <button onclick="selectAll()">Select All</button>
          <button onclick="deselectAll()">Deselect All</button>
          <span id="selectedCount" class="selected-count">0 selected</span>
        </div>
        
        <div id="allEpisodesView">
          <div class="episode-list-container">
            <div class="episode-list-header">
              <span>All Episodes</span>
              <span id="episodeCount">{EPISODE_COUNT} Episodes</span>
            </div>
            <ul id="episodeList">
              <!-- Episodes will be populated here -->
            </ul>
          </div>
        </div>
        
        <div id="seasonsView" style="display: none;">
          <div id="seasonContainers">
            <!-- Season containers will be generated here -->
          </div>
        </div>
        
        <div class="download-settings">
          <h3>Download Settings</h3>
          <div class="setting-row">
            <label for="downloadDelay">Delay between downloads (ms):</label>
            <input type="range" id="downloadDelay" min="100" max="2000" step="100" value="500">
            <span id="delayValue" class="setting-value">500</span>
          </div>
        </div>
        
        <div class="progress">
          <span id="progressText"></span>
          <div class="progress-bar" id="progressBar">
            <div class="progress-bar-fill" id="progressBarFill"></div>
          </div>
        </div>
        
        <div class="actions">
          <button class="download-btn" onclick="downloadSelected()">
            <span>⬇️</span>
            <span>Download Selected</span>
          </button>
          
          <button class="toggle-btn" onclick="toggleDarkMode()">
            <span id="themeIcon">🌙</span>
            <span id="themeText">Dark Mode</span>
          </button>
        </div>
      </div>
    </main>

    <div class="toast" id="toast">
      <span>✅</span>
      <span id="toastMessage"></span>
    </div>
    
    <div class="preview-container" id="previewContainer">
      <div class="preview-content">
        <div class="preview-header">
          <h3 id="previewTitle">Preview</h3>
          <button class="preview-close" onclick="closePreview()">×</button>
        </div>
        <div class="preview-body" id="previewBody">
          <!-- Preview content will be loaded here -->
        </div>
      </div>
    </div>
  </div>

  <script>
    // Episode data structure
    const episodes = {EPISODES_JSON};
    
    // User preferences
    const userPrefs = {
      preferredResolution: 'hd', // Default to HD
      darkMode: false,
      downloadDelay: 500
    };
    
    // Resolution mapping
    const resolutionMap = {
      '1080p': 'hd',
      '720p': 'hd',
      '480p': 'sd',
      '360p': 'lq',
      '240p': 'lq'
    };
    
    // Load saved preferences
    function loadPreferences() {
      const savedPrefs = localStorage.getItem('mediaDownloaderPrefs');
      if (savedPrefs) {
        const prefs = JSON.parse(savedPrefs);
        userPrefs.preferredResolution = prefs.preferredResolution || 'hd';
        userPrefs.darkMode = prefs.darkMode || false;
        userPrefs.downloadDelay = prefs.downloadDelay || 500;
        
        // Apply preferences
        document.getElementById('downloadDelay').value = userPrefs.downloadDelay;
        document.getElementById('delayValue').textContent = userPrefs.downloadDelay;
        
        if (userPrefs.darkMode) {
          document.body.classList.add('dark');
          document.getElementById('themeIcon').textContent = '☀️';
          document.getElementById('themeText').textContent = 'Light Mode';
        }
        
        // Set resolution option
        document.querySelectorAll('.resolution-option').forEach(opt => {
          opt.classList.remove('active');
        });
        document.getElementById(`res${userPrefs.preferredResolution.toUpperCase()}`).classList.add('active');
      }
    }
    
    // Save preferences
    function savePreferences() {
      localStorage.setItem('mediaDownloaderPrefs', JSON.stringify(userPrefs));
    }
    
    // Set preferred resolution
    function setPreferredResolution(resolution) {
      userPrefs.preferredResolution = resolution;
      
      // Update UI
      document.querySelectorAll('.resolution-option').forEach(opt => {
        opt.classList.remove('active');
      });
      document.getElementById(`res${resolution.toUpperCase()}`).classList.add('active');
      
      savePreferences();
      showToast(`Preferred resolution set to ${resolution.toUpperCase()}`);
    }

    // Determine media type from URL or filename
    function getMediaType(url, filename) {
      const lowerUrl = url.toLowerCase();
      const lowerFilename = filename.toLowerCase();
      
      if (lowerUrl.includes('.srt') || lowerUrl.includes('.vtt') || 
          lowerFilename.endsWith('.srt') || lowerFilename.endsWith('.vtt') ||
          lowerUrl.includes('/subtitle/')) {
        return 'subtitle';
      } else if (lowerUrl.includes('.mp4') || lowerUrl.includes('.mkv') || lowerUrl.includes('.avi') ||
                lowerFilename.endsWith('.mp4') || lowerFilename.endsWith('.mkv') || lowerFilename.endsWith('.avi') ||
                lowerUrl.includes('video')) {
        return 'video';
      } else {
        return 'other';
      }
    }
    
    // Determine resolution from URL or filename
    function getResolution(url, filename) {
      const lowerUrl = url.toLowerCase();
      const lowerFilename = filename.toLowerCase();
      
      // Check for common resolution indicators
      if (lowerUrl.includes('1080p') || lowerFilename.includes('1080p')) {
        return '1080p';
      } else if (lowerUrl.includes('720p') || lowerFilename.includes('720p')) {
        return '720p';
      } else if (lowerUrl.includes('480p') || lowerFilename.includes('480p')) {
        return '480p';
      } else if (lowerUrl.includes('360p') || lowerFilename.includes('360p')) {
        return '360p';
      } else if (lowerUrl.includes('240p') || lowerFilename.includes('240p')) {
        return '240p';
      }
      
      // Default to SD if no resolution found
      return '480p';
    }

    // Get icon for media type
    function getMediaIcon(type) {
      switch(type) {
        case 'subtitle': return '📝';
        case 'video': return '🎬';
        default: return '📄';
      }
    }

    // Group episodes by season
    function groupBySeason() {
      const seasons = {};
      episodes.forEach(ep => {
        if (!seasons[ep.season]) {
          seasons[ep.season] = [];
        }
        seasons[ep.season].push(ep);
      });
      return seasons;
    }

    // Populate episode list
    function populateEpisodeList() {
      const allList = document.getElementById('episodeList');
      const seasonContainers = document.getElementById('seasonContainers');
      const count = document.getElementById('episodeCount');
      
      // Clear existing lists
      allList.innerHTML = '';
      seasonContainers.innerHTML = '';
      
      // Group episodes by season
      const seasons = groupBySeason();
      
      // Add all episodes to the main list
      episodes.forEach(ep => {
        const mediaType = getMediaType(ep.url, ep.fname);
        const mediaIcon = getMediaIcon(mediaType);
        const resolution = mediaType === 'video' ? getResolution(ep.url, ep.fname) : null;
        const resolutionClass = resolution ? resolutionMap[resolution] : '';
        
        const li = document.createElement('li');
        li.className = `media-item ${mediaType}`;
        li.dataset.resolution = resolution || '';
        
        let resolutionBadge = '';
        if (resolution) {
          resolutionBadge = `<span class="resolution-badge ${resolutionClass}">${resolution}</span>`;
        }
        
        li.innerHTML = `
          <input type="checkbox" class="epCb" id="s${ep.season}e${ep.episode}" 
                 value="${ep.url}" data-fname="${ep.fname}" 
                 data-season="${ep.season}" data-episode="${ep.episode}"
                 data-media-type="${mediaType}" data-resolution="${resolution || ''}">
          <label for="s${ep.season}e${ep.episode}">
            ${mediaIcon} S${ep.season.toString().padStart(2, '0')}E${ep.episode.toString().padStart(2, '0')}: ${ep.fname}
            <span class="media-type ${mediaType}">${mediaType}</span>
            ${resolutionBadge}
          </label>
          <div class="resolution-selector">
            ${mediaType === 'video' ? `
              <button class="preview-btn" onclick="previewMedia('${ep.url}', '${mediaType}', 'S${ep.season}E${ep.episode}')">👁️ Preview</button>
            ` : mediaType === 'subtitle' ? `
              <button class="preview-btn" onclick="previewMedia('${ep.url}', '${mediaType}', 'S${ep.season}E${ep.episode}')">👁️ Preview</button>
            ` : ''}
          </div>
        `;
        allList.appendChild(li);
      });
      
      // Create season containers
      Object.keys(seasons).sort((a, b) => parseInt(a) - parseInt(b)).forEach(season => {
        const seasonEps = seasons[season];
        const seasonDiv = document.createElement('div');
        seasonDiv.className = 'season-container';
        seasonDiv.innerHTML = `
          <div class="season-header" onclick="toggleSeason(${season})">
            <h2>Season ${season} <span class="season-badge">${seasonEps.length} Episodes</span></h2>
            <span class="chevron">▼</span>
          </div>
          <div class="season-content" id="season${season}Content">
            <div class="selection-controls" style="padding: 10px;">
              <button onclick="selectSeason(${season})">Select All Season ${season}</button>
              <button onclick="deselectSeason(${season})">Deselect Season ${season}</button>
            </div>
            <ul id="season${season}List">
              ${seasonEps.map(ep => {
                const mediaType = getMediaType(ep.url, ep.fname);
                const mediaIcon = getMediaIcon(mediaType);
                const resolution = mediaType === 'video' ? getResolution(ep.url, ep.fname) : null;
                const resolutionClass = resolution ? resolutionMap[resolution] : '';
                
                let resolutionBadge = '';
                if (resolution) {
                  resolutionBadge = `<span class="resolution-badge ${resolutionClass}">${resolution}</span>`;
                }
                
                return `
                  <li class="media-item ${mediaType}" data-resolution="${resolution || ''}">
                    <input type="checkbox" class="epCb seasonEp${season}" id="season${season}ep${ep.episode}" 
                           value="${ep.url}" data-fname="${ep.fname}"
                           data-season="${ep.season}" data-episode="${ep.episode}"
                           data-media-type="${mediaType}" data-resolution="${resolution || ''}">
                    <label for="season${season}ep${ep.episode}">
                      ${mediaIcon} Episode ${ep.episode}: ${ep.fname}
                      <span class="media-type ${mediaType}">${mediaType}</span>
                      ${resolutionBadge}
                    </label>
                    <div class="resolution-selector">
                      ${mediaType === 'video' ? `
                        <button class="preview-btn" onclick="previewMedia('${ep.url}', '${mediaType}', 'S${season}E${ep.episode}')">👁️ Preview</button>
                      ` : mediaType === 'subtitle' ? `
                        <button class="preview-btn" onclick="previewMedia('${ep.url}', '${mediaType}', 'S${season}E${ep.episode}')">👁️ Preview</button>
                      ` : ''}
                    </div>
                  </li>
                `;
              }).join('')}
            </ul>
          </div>
        `;
        seasonContainers.appendChild(seasonDiv);
      });
      
      // Update count
      count.textContent = `${episodes.length} Episodes`;
      
      // Add event listeners to checkboxes
      document.querySelectorAll('.epCb').forEach(checkbox => {
        checkbox.addEventListener('change', function() {
          // Sync checkboxes between views
          const season = this.dataset.season;
          const episode = this.dataset.episode;
          const isChecked = this.checked;
          
          // Find and update the corresponding checkbox in the other view
          if (this.id.startsWith('s')) {
            // Main list checkbox changed, update season view
            const seasonCheckbox = document.getElementById(`season${season}ep${episode}`);
            if (seasonCheckbox) seasonCheckbox.checked = isChecked;
          } else {
            // Season view checkbox changed, update main list
            const mainCheckbox = document.getElementById(`s${season}e${episode}`);
            if (mainCheckbox) mainCheckbox.checked = isChecked;
          }
          
          updateSelectedCount();
        });
      });
      
      updateSelectedCount();
    }

    // Preview media
    async function previewMedia(url, mediaType, title) {
      const previewContainer = document.getElementById('previewContainer');
      const previewTitle = document.getElementById('previewTitle');
      const previewBody = document.getElementById('previewBody');
      
      previewTitle.textContent = `Preview: ${title}`;
      previewBody.innerHTML = '<div style="text-align: center; padding: 20px;">Loading preview...</div>';
      
      previewContainer.classList.add('active');
      
      try {
        if (mediaType === 'video') {
          // Video preview
          previewBody.innerHTML = `
            <video class="preview-video" controls>
              <source src="${url}" type="video/mp4">
              Your browser does not support the video tag.
            </video>
          `;
        } else if (mediaType === 'subtitle') {
          // Subtitle preview
          const response = await fetch(url);
          if (!response.ok) throw new Error('Failed to fetch subtitle');
          
          const text = await response.text();
          previewBody.innerHTML = `<pre class="preview-subtitle">${text}</pre>`;
        } else {
          // Generic preview
          previewBody.innerHTML = `
            <div style="padding: 20px; text-align: center;">
              <p>Preview not available for this media type.</p>
              <a href="${url}" target="_blank" class="download-btn" style="display: inline-block; margin-top: 10px;">
                Open in new tab
              </a>
            </div>
          `;
        }
      } catch (error) {
        previewBody.innerHTML = `
          <div style="padding: 20px; text-align: center; color: var(--primary);">
            <p>Error loading preview: ${error.message}</p>
            <a href="${url}" target="_blank" class="download-btn" style="display: inline-block; margin-top: 10px;">
              Try opening in new tab
            </a>
          </div>
        `;
      }
    }

    // Close preview
    function closePreview() {
      const previewContainer = document.getElementById('previewContainer');
      const previewBody = document.getElementById('previewBody');
      
      previewContainer.classList.remove('active');
      // Clear content after animation completes
      setTimeout(() => {
        previewBody.innerHTML = '';
      }, 300);
    }

    // Filter media by type
    function filterMedia(type) {
      // Update active filter button
      document.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
      document.getElementById(`filter${type.charAt(0).toUpperCase() + type.slice(1)}`).classList.add('active');
      
      // Filter items in main list
      document.querySelectorAll('#episodeList .media-item').forEach(item => {
        if (type === 'all' || item.classList.contains(type)) {
          item.style.display = '';
        } else {
          item.style.display = 'none';
        }
      });
      
      // Filter items in season lists
      document.querySelectorAll('[id^="season"][id$="List"] .media-item').forEach(item => {
        if (type === 'all' || item.classList.contains(type)) {
          item.style.display = '';
        } else {
          item.style.display = 'none';
        }
      });
      
      showToast(`Showing ${type === 'all' ? 'all media' : type + ' files'}`);
    }

    // Toggle season content visibility
    function toggleSeason(season) {
      const content = document.getElementById(`season${season}Content`);
      const chevron = content.previousElementSibling.querySelector('.chevron');
      
      content.classList.toggle('open');
      chevron.classList.toggle('open');
    }

    // Select all episodes in a season
    function selectSeason(season) {
      document.querySelectorAll(`.seasonEp${season}`).forEach(checkbox => {
        // Only select visible items (respects current filter)
        if (checkbox.closest('li').style.display !== 'none') {
          checkbox.checked = true;
          
          // Update corresponding checkbox in main list
          const mainCheckbox = document.getElementById(`s${season}e${checkbox.dataset.episode}`);
          if (mainCheckbox) mainCheckbox.checked = true;
        }
      });
      
      updateSelectedCount();
      showToast(`Selected all visible episodes in Season ${season}`);
    }

    // Deselect all episodes in a season
    function deselectSeason(season) {
      document.querySelectorAll(`.seasonEp${season}`).forEach(checkbox => {
        checkbox.checked = false;
        
        // Update corresponding checkbox in main list
        const mainCheckbox = document.getElementById(`s${season}e${checkbox.dataset.episode}`);
        if (mainCheckbox) mainCheckbox.checked = false;
      });
      
      updateSelectedCount();
      showToast(`Deselected all episodes in Season ${season}`);
    }

    // Tab switching
    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', function() {
        // Update active tab
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        this.classList.add('active');
        
        // Show/hide views
        const tabName = this.dataset.tab;
        if (tabName === 'all') {
          document.getElementById('allEpisodesView').style.display = 'block';
          document.getElementById('seasonsView').style.display = 'none';
        } else {
          document.getElementById('allEpisodesView').style.display = 'none';
          document.getElementById('seasonsView').style.display = 'block';
        }
      });
    });

    // Download delay slider
    document.getElementById('downloadDelay').addEventListener('input', function() {
      const value = parseInt(this.value);
      document.getElementById('delayValue').textContent = value;
      userPrefs.downloadDelay = value;
      savePreferences();
    });

    // Track selected count
    function updateSelectedCount() {
      const count = document.querySelectorAll('#episodeList input[type="checkbox"]:checked').length;
      const countElement = document.getElementById('selectedCount');
      countElement.textContent = count === 1 ? '1 selected' : `${count} selected`;
    }

    // Parse season and episode from string like "S01E05"
    function parseSeasonEpisode(str) {
      const regex = /S(\d+)E(\d+)/i;
      const match = str.match(regex);
      if (match) {
        return {
          season: parseInt(match[1]),
          episode: parseInt(match[2])
        };
      }
      return null;
    }

    // Select episodes by range
    function selectRange() {
      const input = document.getElementById('rangeInput').value.trim();
      
      if (!input) {
        showToast('Please enter a valid range!', 3000);
        return;
      }
      
      // First uncheck all
      document.querySelectorAll('.epCb').forEach(checkbox => {
        checkbox.checked = false;
      });
      
      let start, end;
      let count = 0;
      
      if (input.includes('-')) {
        // Range like S01E02-S01E05 or S01E02-E05
        const [startStr, endStr] = input.split('-').map(s => s.trim());
        
        start = parseSeasonEpisode(startStr);
        if (!start) {
          showToast('Invalid start format! Use S01E02 format.', 3000);
          return;
        }
        
        // Handle end format: S01E05 or just E05
        if (endStr.toUpperCase().startsWith('E')) {
          // Format is E05, use same season as start
          const epNum = parseInt(endStr.substring(1));
          if (isNaN(epNum)) {
            showToast('Invalid end episode number!', 3000);
            return;
          }
          end = { season: start.season, episode: epNum };
        } else {
          // Format is S01E05
          end = parseSeasonEpisode(endStr);
          if (!end) {
            showToast('Invalid end format! Use S01E05 format.', 3000);
            return;
          }
        }
      } else {
        // Single episode like S01E05
        start = parseSeasonEpisode(input);
        if (!start) {
          showToast('Invalid format! Use S01E05 format.', 3000);
          return;
        }
        end = start;
      }
      
      // Select episodes in range
      episodes.forEach(ep => {
        if (
          (ep.season > start.season || (ep.season === start.season && ep.episode >= start.episode)) &&
          (ep.season < end.season || (ep.season === end.season && ep.episode <= end.episode))
        ) {
          // Only select visible items (respects current filter)
          const mainCheckbox = document.getElementById(`s${ep.season}e${ep.episode}`);
          const seasonCheckbox = document.getElementById(`season${ep.season}ep${ep.episode}`);
          
          if (mainCheckbox && mainCheckbox.closest('li').style.display !== 'none') {
            mainCheckbox.checked = true;
            count++;
          }
          
          if (seasonCheckbox) {
            seasonCheckbox.checked = true;
          }
        }
      });
      
      updateSelectedCount();
      
      const rangeText = start.season === end.season && start.episode === end.episode
        ? `S${start.season.toString().padStart(2, '0')}E${start.episode.toString().padStart(2, '0')}`
        : `S${start.season.toString().padStart(2, '0')}E${start.episode.toString().padStart(2, '0')} to S${end.season.toString().padStart(2, '0')}E${end.episode.toString().padStart(2, '0')}`;
      
      showToast(`Selected ${count} episodes in range ${rangeText}`);
    }

    // Select all episodes
    function selectAll() {
      document.querySelectorAll('#episodeList .media-item').forEach(item => {
        // Only select visible items (respects current filter)
        if (item.style.display !== 'none') {
          const checkbox = item.querySelector('.epCb');
          if (checkbox) checkbox.checked = true;
        }
      });
      updateSelectedCount();
      showToast('All visible episodes selected');
    }

    // Deselect all episodes
    function deselectAll() {
      document.querySelectorAll('.epCb').forEach(checkbox => {
        checkbox.checked = false;
      });
      updateSelectedCount();
      showToast('All episodes deselected');
    }

    // Search functionality
    document.getElementById('searchInput').addEventListener('input', function() {
      const searchTerm = this.value.toLowerCase();
      
      // Search in main list
      document.querySelectorAll('#episodeList li').forEach(item => {
        const text = item.textContent.toLowerCase();
        if (text.includes(searchTerm)) {
          item.style.display = '';
        } else {
          item.style.display = 'none';
        }
      });
      
      // Search in season lists
      document.querySelectorAll('[id^="season"][id$="List"] li').forEach(item => {
        const text = item.textContent.toLowerCase();
        if (text.includes(searchTerm)) {
          item.style.display = '';
          // Make sure the season container is open
          const seasonId = item.closest('[id^="season"][id$="Content"]').id;
          const seasonNum = seasonId.replace('season', '').replace('Content', '');
          document.getElementById(`season${seasonNum}Content`).classList.add('open');
        } else {
          item.style.display = 'none';
        }
      });
    });

    // Show toast notification
    function showToast(message, duration = 3000) {
      const toast = document.getElementById('toast');
      const toastMessage = document.getElementById('toastMessage');
      
      toastMessage.textContent = message;
      toast.classList.add('show');
      
      setTimeout(() => {
        toast.classList.remove('show');
      }, duration);
    }

    // Toggle dark/light mode
    function toggleDarkMode() {
      const isDarkMode = document.body.classList.toggle('dark');
      userPrefs.darkMode = isDarkMode;
      savePreferences();
      
      const themeIcon = document.getElementById('themeIcon');
      const themeText = document.getElementById('themeText');
      
      themeIcon.textContent = isDarkMode ? '☀️' : '🌙';
      themeText.textContent = isDarkMode ? 'Light Mode' : 'Dark Mode';
      
      // Add fade-in animation to the container
      const container = document.querySelector('.container');
      container.style.animation = 'fadeIn 0.5s';
      setTimeout(() => { container.style.animation = ''; }, 500);
    }

    // Get appropriate file extension based on media type
    function getFileExtension(url, mediaType) {
      if (url.includes('.srt')) return '.srt';
      if (url.includes('.vtt')) return '.vtt';
      if (url.includes('.mp4')) return '.mp4';
      if (url.includes('.mkv')) return '.mkv';
      if (url.includes('.avi')) return '.avi';
      
      // Default extensions based on media type
      switch(mediaType) {
        case 'subtitle': return '.srt';
        case 'video': return '.mp4';
        default: return '.txt';
      }
    }

    // Download selected media
    async function downloadSelected() {
      const selected = document.querySelectorAll('#episodeList input[type="checkbox"]:checked');
      
      if (selected.length === 0) {
        showToast('Please select at least one episode', 3000);
        return;
      }
      
      const progressText = document.getElementById('progressText');
      const progressBar = document.getElementById('progressBar');
      const progressBarFill = document.getElementById('progressBarFill');
      const downloadDelay = userPrefs.downloadDelay;
      
      progressText.textContent = `Preparing to download ${selected.length} files...`;
      progressBar.style.display = 'block';
      progressBarFill.style.width = '0%';
      
      let successCount = 0;
      let failCount = 0;
      
      for (let i = 0; i < selected.length; i++) {
        const checkbox = selected[i];
        const listItem = checkbox.closest('li');
        const url = checkbox.value;
        const fname = checkbox.dataset.fname;
        const mediaType = checkbox.dataset.mediaType;
        
        try {
          // Update progress
          progressText.textContent = `Downloading ${i + 1}/${selected.length}: ${fname}`;
          progressBarFill.style.width = `${((i + 1) / selected.length) * 100}%`;
          
          // Add visual pulse effect
          listItem.style.animation = 'pulse 0.5s';
          
          // Fetch and download the file
          const res = await fetch(url);
          if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`);
          
          const blob = await res.blob();
          const a = document.createElement('a');
          a.href = URL.createObjectURL(blob);
          
          // Ensure filename has appropriate extension
          let downloadName = fname;
          if (!downloadName.includes('.')) {
            const ext = getFileExtension(url, mediaType);
            downloadName += ext;
          }
          
          a.download = downloadName;
          a.click();
          
          // Mark as downloaded
          listItem.classList.add('downloaded');
          successCount++;
          
          // Small delay between downloads (configurable)
          await new Promise(r => setTimeout(r, downloadDelay));
        } catch (error) {
          console.error(`Error downloading ${fname}:`, error);
          failCount++;
        } finally {
          // Reset animation
          setTimeout(() => { listItem.style.animation = ''; }, 500);
        }
      }
      
      // Show completion message
      if (failCount === 0) {
        progressText.textContent = `✅ Successfully downloaded ${successCount} files!`;
        showToast(`Downloaded ${successCount} files successfully!`, 4000);
      } else {
        progressText.textContent = `✅ Downloaded ${successCount} files, ❌ Failed: ${failCount}`;
        showToast(`Downloaded ${successCount} files, ${failCount} failed`, 4000);
      }

      // Hide progress bar after a delay
      setTimeout(() => {
        progressBar.style.display = 'none';
      }, 5000);
    }

    // Add fade-in animation on page load
    document.addEventListener('DOMContentLoaded', () => {
      document.querySelector('.container').style.animation = 'fadeIn 0.8s';
      
      // Load user preferences
      loadPreferences();
      
      // Open first season by default in season view
      const firstSeason = document.querySelector('.season-content');
      if (firstSeason) {
        firstSeason.classList.add('open');
        firstSeason.previousElementSibling.querySelector('.chevron').classList.add('open');
      }
      
      populateEpisodeList();
    });
  </script>
</body>
</html>